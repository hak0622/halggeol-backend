<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.halggeol.backend.recommend.mapper.RecommendMapper">
  <resultMap id="DepositAlgorithmResponseDTOMap" type="com.halggeol.backend.recommend.dto.DepositAlgorithmResponseDTO">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="primeRate" column="prime_rate"/>
    <result property="extraDeposit" column="extra_deposit"/>
    <result property="rate" column="rate"/>
    <result property="maxSaveTerm" column="max_save_term"/>
    <result property="minSaveTerm" column="min_save_term"/>
    <result property="joinDeny" column="join_deny"/>
    <result property="maxLimit" column="max_limit"/>
    <result property="minLimit" column="min_limit"/>
    <result property="fSector" column="f_sector"/>
    <result property="rateType" column="rate_type"/>
  </resultMap>

  <select id="getDepositAlgorithmDetail" resultMap="DepositAlgorithmResponseDTOMap">
    SELECT
        id,
        name,
        prime_rate,
        extra_deposit,
        rate,
        max_save_term,
        min_save_term,
        join_deny,
        max_limit,
        min_limit,
        f_sector,
        rate_type
    FROM deposit
  </select>

  <update id="updateDepositAlgoCodeById">
    UPDATE deposit
    SET
        deposit.algo_code = #{algoCode},
        deposit.yield_score = #{yieldScore},
        deposit.risk_score = #{riskScore},
        deposit.liquidity_score = #{liquidityScore},
        deposit.complexity_score = #{complexityScore},
        deposit.cost_score = #{costScore}
    WHERE deposit.id = #{pid}
  </update>

  <resultMap id="SavingsAlgorithmResponseDTOMap" type="com.halggeol.backend.recommend.dto.SavingsAlgorithmResponseDTO">
    <id property="id" column="id"/>
    <result property="rateType" column="rate_type"/>
    <result property="rate" column="rate"/>
    <result property="fSector" column="f_sector"/>
    <result property="maxLimit" column="max_limit"/>
    <result property="joinDeny" column="join_deny"/>
    <result property="minSaveTerm" column="min_save_term"/>
    <result property="maxSaveTerm" column="max_save_term"/>
    <result property="primeRate" column="prime_rate"/>
    <result property="name" column="name"/>
    <result property="minLimit" column="min_limit"/>
  </resultMap>

  <select id="getSavingsAlgorithmDetail" resultMap="SavingsAlgorithmResponseDTOMap">
    SELECT
      s.id as id,
      s.rate_type as rate_type,
      s.rate as rate,
      s.f_sector as f_sector,
      s.max_limit as max_limit,
      s.join_deny as join_deny,
      s.min_save_term as min_save_term,
      s.max_save_term as max_save_term,
      s.prime_rate as prime_rate,
      s.name as name,
      s.min_limit as min_limit
    FROM savings s
    </select>

  <update id="updateSavingsAlgoCodeById">
    UPDATE savings
    SET
        savings.algo_code = #{algoCode}
        ,savings.yield_score = #{yieldScore}
        ,savings.risk_score = #{riskScore}
        ,savings.cost_score = #{costScore}
        ,savings.liquidity_score = #{liquidityScore}
        ,savings.complexity_score = #{complexityScore}
    WHERE savings.id = #{pid}
  </update>

  <resultMap id="FundAlgorithmResponseDTOMap" type="com.halggeol.backend.recommend.dto.FundAlgorithmResponseDTO">
    <id property="id" column="Id"/>
    <result property="name" column="name"/>
    <result property="rate" column="rate"/>
    <result property="fundPrice" column="fund_price"/>
    <result property="fundPriceMovement" column="fund_price_movement"/>
    <result property="investmentType" column="investment_type"/>
    <result property="investmentWarningGrade" column="investment_warning_grade"/>
    <result property="managementFee" column="management_fee"/>
    <result property="TER" column="TER"/>
    <result property="upfrontFee" column="upfront_fee"/>
    <result property="category" column="category"/>
    <result property="minLimit" column="min_limit"/>
    <result property="risk" column="risk"/>
  </resultMap>

  <select id="getFundAlgorithmDetail" resultMap="FundAlgorithmResponseDTOMap">
    SELECT
      f.id as Id,
      f.name,
      f.rate,
      f.fund_price,
      f.fund_price_movement,
      f.investment_type,
      f.investment_warning_grade,
      f.management_fee,
      f.TER,
      f.upfront_fee,
      f.min_limit,
      f.category,
      f.risk
    FROM fund f</select>
  
  <update id="updateFundAlgoCodeById">
    UPDATE fund
    SET fund.algo_code = #{algoCode},
    fund.yield_score = #{yieldScore},
    fund.risk_score = #{riskScore},
    fund.cost_score = #{costScore},
    fund.liquidity_score = #{liquidityScore},
    fund.complexity_score = #{complexityScore}
    WHERE fund.id = #{pid}</update>
  <resultMap id="PensionAlgorithmResponseDTOMap" type="com.halggeol.backend.recommend.dto.PensionAlgorithmResponseDTO">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="minLimit" column="min_limit"/>
    <result property="maxLimit" column="max_limit"/>
    <result property="fSector" column="f_sector"/>
    <result property="rateType" column="rate_type"/>
    <result property="rate" column="rate"/>
    <result property="risk" column="risk"/>
    <result property="pensionType" column="pension_type"/>
    <result property="pensionKind" column="pension_kind"/>
    <result property="minGuaranteeRate" column="min_guarantee_rate"/>
    <result property="TER" column="TER"/>
    <result property="saveTerm" column="save_term"/>
  </resultMap>

  <select id="getPensionAlgorithmDetail" resultMap="PensionAlgorithmResponseDTOMap">
    SELECT
      p.id as id,
      p.name,
      p.min_limit as min_limit,
      p.max_limit as max_limit,
      p.f_sector as f_sector,
      p.rate_type as rate_type,
      p.rate as rate,
      p.risk as risk,
      p.pension_type as pension_type,
      p.pension_kind as pension_kind,
      p.min_guarantee_rate as min_guarantee_rate,
      p.TER as TER,
      p.save_term as save_term
    FROM pension p
    </select>

  <update id="updatePensionAlgoCodeById">
    UPDATE pension
    SET pension.algo_code = #{algoCode}
    ,pension.yield_score = #{yieldScore}
    ,pension.risk_score = #{riskScore}
    ,pension.cost_score = #{costScore}
    ,pension.liquidity_score = #{liquidityScore}
    ,pension.complexity_score = #{complexityScore}
    WHERE pension.id = #{pid}</update>

  <resultMap id="ForexAlgorithmResponseDTOMap" type="com.halggeol.backend.recommend.dto.ForexAlgorithmResponseDTO">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="rate" column="rate"/>
    <result property="maxLimit" column="max_limit"/>
    <result property="minLimit" column="min_limit"/>
    <result property="maxSaveTerm" column="max_save_term"/>
    <result property="minSaveTerm" column="min_save_term"/>
    <result property="extraDeposit" column="extra_deposit"/>
    <result property="autoRenew" column="auto_renew"/>
    <result property="taxRefund" column="tax_refund"/>
    <result property="protect" column="protect"/>
    <result property="currency" column="currency"/>
    <result property="risk" column="risk"/>
  </resultMap>

  <select id="getForexAlgorithmDetail" resultMap="ForexAlgorithmResponseDTOMap">
    SELECT
      fx.id as id,
      fx.name,
      fx.rate,
      fx.max_limit as max_limit,
      fx.min_limit as min_limit,
      fx.max_save_term as max_save_term,
      fx.min_save_term as min_save_term,
      fx.extra_deposit as extra_deposit,
      fx.auto_renew as auto_renew,
      fx.tax_refund as tax_refund,
      fx.protect as protect,
      fx.currency as currency,
      fx.risk as risk
    FROM forex fx
  </select>

  <update id="updateForexAlgoCodeById">
    UPDATE forex
    SET forex.algo_code = #{algoCode}
    ,forex.yield_score = #{yieldScore}
    ,forex.risk_score = #{riskScore}
    ,forex.cost_score = #{costScore}
    ,forex.liquidity_score = #{liquidityScore}
    ,forex.complexity_score = #{complexityScore}
    WHERE forex.id = #{pid}</update>
  
  <resultMap id="ProductVectorResponseDTOMap" type="com.halggeol.backend.recommend.dto.ProductVectorResponseDTO">
    <id property="id" column="id"/>
    <result property="yieldScore" column="yield_score"/>
    <result property="riskScore" column="risk_score"/>
    <result property="costScore" column="cost_score"/>
    <result property="liquidityScore" column="liquidity_score"/>
    <result property="complexityScore" column="complexity_score"/>
  </resultMap>
  
  <select id="getProductVectors" resultMap="ProductVectorResponseDTOMap">
    SELECT
      id,
      yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM deposit
    union all
    SELECT
      id,
      yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM savings
    union all
    SELECT
      id,
      fund.yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM fund
    union all
    SELECT
      id,
      yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM pension
    union all
    SELECT
      id,
      yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM forex
  </select>

  <resultMap id="UserVectorResponseDTOMap" type="com.halggeol.backend.recommend.dto.UserVectorResponseDTO">
    <id property="id" column="id"/>
    <result property="yieldScore" column="yield_score"/>
    <result property="riskScore" column="risk_score"/>
    <result property="costScore" column="cost_score"/>
    <result property="liquidityScore" column="liquidity_score"/>
    <result property="complexityScore" column="complexity_score"/>
  </resultMap>

  <select id="getUserVectors" resultMap="UserVectorResponseDTOMap">
    SELECT
      id,
      yield_score,
      risk_score,
      cost_score,
      liquidity_score,
      complexity_score
    FROM users
    </select>


  <insert id="saveRecommendations" parameterType="map">
    INSERT INTO rec_item (
          user_id,
         rec_date,
      product1_id,
      product2_id,
      product3_id,
      product4_id,
      product5_id
    ) VALUES (
          #{userId},
              NOW(),
      #{product1Id},
      #{product2Id},
      #{product3Id},
      #{product4Id},
      #{product5Id}
    )
  </insert>

  <select id="getUserById" resultType="com.halggeol.backend.security.domain.User">
    SELECT * FROM users WHERE id = #{id}
  </select>

  <select id="getProductVectorById" resultMap="ProductVectorResponseDTOMap">
  SELECT
  id,
  yield_score,
  risk_score,
  cost_score,
  liquidity_score,
  complexity_score
  FROM deposit WHERE id = #{id}
  UNION ALL
  SELECT
  id,
  yield_score,
  risk_score,
  cost_score,
  liquidity_score,
  complexity_score
  FROM savings WHERE id = #{id}
  UNION ALL
  SELECT
  id,
  yield_score,
  risk_score,
  cost_score,
  liquidity_score,
  complexity_score
  FROM fund WHERE id = #{id}
  UNION ALL
  SELECT
  id,
  yield_score,
  risk_score,
  cost_score,
  liquidity_score,
  complexity_score
  FROM pension WHERE id = #{id}
  UNION ALL
  SELECT
  id,
  yield_score,
  risk_score,
  cost_score,
  liquidity_score,
  complexity_score
  FROM forex WHERE id = #{id}
  </select>

  <resultMap id="RecommendResponseDTOMap" type="com.halggeol.backend.recommend.dto.RecommendResponseDTO">
    <result property="productId" column="product_id"/>
    <result property="name" column="product_name"/>
  </resultMap>

  <select id="getRecommendationsByUserId" resultMap="RecommendResponseDTOMap">
    SELECT DISTINCT
      product_id,
      product_name
    FROM (
      SELECT
        ri.product1_id AS product_id,
        COALESCE(d.name, s.name, f.name, p.name, fx.name) AS product_name
      FROM rec_item ri
      LEFT JOIN deposit d ON ri.product1_id = d.id
      LEFT JOIN savings s ON ri.product1_id = s.id
      LEFT JOIN fund f ON ri.product1_id = f.id
      LEFT JOIN pension p ON ri.product1_id = p.id
      LEFT JOIN forex fx ON ri.product1_id = fx.id
      WHERE ri.user_id = #{userId} AND ri.rec_id = (SELECT MAX(rec_id) FROM rec_item WHERE user_id = #{userId})
        AND ri.product1_id IS NOT NULL

      UNION ALL

      SELECT
        ri.product2_id AS product_id,
        COALESCE(d.name, s.name, f.name, p.name, fx.name) AS product_name
      FROM rec_item ri
      LEFT JOIN deposit d ON ri.product2_id = d.id
      LEFT JOIN savings s ON ri.product2_id = s.id
      LEFT JOIN fund f ON ri.product2_id = f.id
      LEFT JOIN pension p ON ri.product2_id = p.id
      LEFT JOIN forex fx ON ri.product2_id = fx.id
      WHERE ri.user_id = #{userId} AND ri.rec_id = (SELECT MAX(rec_id) FROM rec_item WHERE user_id = #{userId})
        AND ri.product2_id IS NOT NULL

      UNION ALL

      SELECT
        ri.product3_id AS product_id,
        COALESCE(d.name, s.name, f.name, p.name, fx.name) AS product_name
      FROM rec_item ri
      LEFT JOIN deposit d ON ri.product3_id = d.id
      LEFT JOIN savings s ON ri.product3_id = s.id
      LEFT JOIN fund f ON ri.product3_id = f.id
      LEFT JOIN pension p ON ri.product3_id = p.id
      LEFT JOIN forex fx ON ri.product3_id = fx.id
      WHERE ri.user_id = #{userId} AND ri.rec_id = (SELECT MAX(rec_id) FROM rec_item WHERE user_id = #{userId})
        AND ri.product3_id IS NOT NULL

      UNION ALL

      SELECT
        ri.product4_id AS product_id,
        COALESCE(d.name, s.name, f.name, p.name, fx.name) AS product_name
      FROM rec_item ri
      LEFT JOIN deposit d ON ri.product4_id = d.id
      LEFT JOIN savings s ON ri.product4_id = s.id
      LEFT JOIN fund f ON ri.product4_id = f.id
      LEFT JOIN pension p ON ri.product4_id = p.id
      LEFT JOIN forex fx ON ri.product4_id = fx.id
      WHERE ri.user_id = #{userId} AND ri.rec_id = (SELECT MAX(rec_id) FROM rec_item WHERE user_id = #{userId})
        AND ri.product4_id IS NOT NULL

      UNION ALL

      SELECT
        ri.product5_id AS product_id,
        COALESCE(d.name, s.name, f.name, p.name, fx.name) AS product_name
      FROM rec_item ri
      LEFT JOIN deposit d ON ri.product5_id = d.id
      LEFT JOIN savings s ON ri.product5_id = s.id
      LEFT JOIN fund f ON ri.product5_id = f.id
      LEFT JOIN pension p ON ri.product5_id = p.id
      LEFT JOIN forex fx ON ri.product5_id = fx.id
      WHERE ri.user_id = #{userId} AND ri.rec_id = (SELECT MAX(rec_id) FROM rec_item WHERE user_id = #{userId})
        AND ri.product5_id IS NOT NULL
    ) AS recommendations
    WHERE product_name IS NOT NULL
  </select>

  <select id="getMaxRate" resultType="double">
    SELECT MAX(rate) FROM (
      SELECT rate FROM deposit
      UNION ALL
      SELECT rate FROM savings
      UNION ALL
      SELECT rate FROM fund
      UNION ALL
      SELECT rate FROM pension
      UNION ALL
      SELECT rate FROM forex
    ) AS combined_rates
  </select>

  <select id="getMinRate" resultType="double">
    SELECT MIN(rate) FROM (
        SELECT rate FROM deposit
        UNION ALL
        SELECT rate FROM savings
        UNION ALL
        SELECT rate FROM fund
        UNION ALL
        SELECT rate FROM pension
        UNION ALL
        SELECT rate FROM forex
    ) AS combined_rates
  </select>

  <select id="getMaxSaveTerm" resultType="int">
  SELECT MAX(max_save_term) FROM (
  SELECT max_save_term FROM deposit
  UNION ALL
  SELECT max_save_term FROM savings
  ) AS combined_terms
  </select>

  <select id="getMinSaveTerm" resultType="int">
  SELECT MIN(min_save_term) FROM (
  SELECT min_save_term FROM deposit
  UNION ALL
  SELECT min_save_term FROM savings
  ) AS combined_terms
  </select>

  <select id="getMaxFundPriceMovement" resultType="double">
  SELECT MAX(fund_price_movement) FROM fund
  </select>

  <select id="getMinFundPriceMovement" resultType="double">
  SELECT MIN(fund_price_movement) FROM fund
  </select>
  <select id="getMaxFundTER" resultType="double">
  SELECT MAX(TER) FROM fund
  </select>
  <select id="getMinFundTER" resultType="double">
  SELECT MIN(TER) FROM fund
  </select>
</mapper>